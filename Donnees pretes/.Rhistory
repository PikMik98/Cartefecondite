`GEO (Codes)` == "HR047" ~ "HR021",
`GEO (Codes)` == "HR046" ~ "HR061",
`GEO (Codes)` == "HR045" ~ "HR063",
`GEO (Codes)` == "HR044" ~ "HR062",
`GEO (Codes)` == "HR043" ~ "HR064",
`GEO (Codes)` == "HR042" ~ "HR065",
`GEO (Codes)` == "HR041" ~ "HR050",
TRUE ~ `GEO (Codes)`
))
################################################################################
nuts_all <- nuts_all %>%
filter(!grepl("^MK|^RS|^TR|^ME|^AL|^IE", CNTR_CODE))
# Filtrer pour le niveau NUTS 3 uniquement
nuts3 <- nuts_all[nuts_all$LEVL_CODE == 3, ]
nuts3 <- nuts3 %>%
filter(!grepl("^DE|^BE|^NL|^PT|^EL|^UK", CNTR_CODE))
# Filtrer pour le niveau NUTS 3 uniquement
nuts2 <- nuts_all[nuts_all$LEVL_CODE == 2, ]
nuts2 <- nuts2 %>%
filter(grepl("^DE|^BE|^NL|^PT|^EL|^UK", CNTR_CODE))
################################################################################
nuts3_mod <- nuts3 %>%
mutate(NUTS3_modifie = case_when(
NUTS_ID %in% c("EE009", "EE00A") ~ "EE006_7",
NUTS_ID %in% c("ITG25", "ITG29") ~ "ITG2D",
NUTS_ID %in% c("ITG2E", "ITG2F", "ITG2G", "ITG2H") ~ "ITG2D_1",
NUTS_ID %in% c("PL218", "PL219", "PL21A") ~ "PL21_A",
NUTS_ID %in% c("PL426", "PL427", "PL428") ~ "PL42_A",
NUTS_ID %in% c("PL523", "PL524") ~ "PL52_A",
NUTS_ID %in% c("PL616", "PL617", "PL618", "PL619") ~ "PL61_A",
NUTS_ID %in% c("PL636", "PL637", "PL638") ~ "PL63_A",
NUTS_ID %in% c("SI034", "SI035", "SI036", "SI041") ~ "SI0_3_4",
NUTS_ID %in% c("FI1D8", "FI1D9") ~ "FI1D_A",
TRUE ~ NUTS_ID
))
nuts3_fusion <- nuts3_mod %>%
group_by(NUTS3_modifie) %>%
summarise(geometry = st_union(geometry), .groups = "drop") %>%
st_transform(crs = 4326) %>%
st_make_valid()
################################################################################
################################################################################
###Création carte NUTS2_3 et reconstitution des polygones###
# 1. Identifier les régions utilisées dans des fusions
regions_a_supprimer <- nuts3_mod %>%
filter(NUTS_ID != NUTS3_modifie) %>%
pull(NUTS_ID)
# 2. Garder uniquement les régions NUTS3 non concernées par une fusion
nuts3_non_fusionnees <- nuts3 %>%
filter(!NUTS_ID %in% regions_a_supprimer) %>%
select(everything())
meta_fusion <- st_drop_geometry(nuts3) %>%  # enlève la géométrie pour la jointure
left_join(nuts3_mod %>% st_drop_geometry() %>% select(NUTS_ID, NUTS3_modifie), by = "NUTS_ID") %>%
filter(NUTS_ID != NUTS3_modifie) %>%
group_by(NUTS3_modifie) %>%
summarise(
LEVL_CODE = first(LEVL_CODE),
CNTR_CODE = first(CNTR_CODE),
NAME_LATN = first(NAME_LATN),
NUTS_NAME = first(NUTS_NAME),
MOUNT_TYPE = first(MOUNT_TYPE),
URBN_TYPE = first(URBN_TYPE),
COAST_TYPE = first(COAST_TYPE),
.groups = "drop"
)
nuts3_fusionnees <- meta_fusion %>%
left_join(nuts3_fusion %>% rename(NUTS3_modifie = NUTS3_modifie), by = "NUTS3_modifie") %>%
rename(NUTS_ID = NUTS3_modifie) %>%
select(LEVL_CODE, NUTS_ID, CNTR_CODE, NAME_LATN, NUTS_NAME,
MOUNT_TYPE, URBN_TYPE, COAST_TYPE, geometry) %>%
st_as_sf()  # reconvertir en objet sf
# Harmoniser la projection : transformer nuts3_non_fusionnees au même CRS que nuts3_fusionnees
nuts3_non_fusionnees <- st_transform(nuts3_non_fusionnees, crs = st_crs(nuts3_fusionnees))
# Ensuite, tu peux faire la fusion proprement
nuts3_final <- bind_rows(nuts3_non_fusionnees, nuts3_fusionnees)
# Harmonisation du CRS
nuts2 <- st_transform(nuts2, crs = st_crs(nuts3_final))
# Concaténation des deux couches
nuts2_3 <- bind_rows(nuts3_final, nuts2)
leaflet(nuts2_3) %>%
addTiles() %>%
addPolygons(
label = ~NUTS_ID,
color = "black", weight = 1, opacity = 1,
fillColor = "indianred", fillOpacity = 1
)
################################################################################
################################################################################
##################################
####Calcul des couples voisins####
##################################
# On s'assure que la géométrie est bien valide
nuts2_3 <- st_make_valid(nuts2_3)
# Pour gagner du temps de calcul, on crée un index spatial
st_agr(nuts2_3) = "constant"
# On calcule les voisins (renvoie une liste d'indices)
neighbors <- st_touches(nuts2_3)
# On transforme en data.frame avec les noms des régions
adjacency_df <- do.call(rbind, lapply(seq_along(neighbors), function(i) {
if (length(neighbors[[i]]) == 0) return(NULL)
data.frame(
NUTS_ID_1 = nuts2_3$NUTS_ID[i],
NUTS_ID_2 = nuts2_3$NUTS_ID[neighbors[[i]]]
)
}))
# Éviter les doublons (A-B et B-A)
adjacency_unique <- adjacency_df %>%
rowwise() %>%
mutate(
region_min = min(NUTS_ID_1, NUTS_ID_2),
region_max = max(NUTS_ID_1, NUTS_ID_2)
) %>%
ungroup() %>%
select(region_min, region_max) %>%
distinct()
# Renommer les colonnes proprement
adjacency_final <- adjacency_unique %>%
rename(NUTS_ID_1 = region_min, NUTS_ID_2 = region_max)
##########################TEST de voisinage##############################
############TEST1########################
# Choisir un couple à visualiser
i <- 1511
# changer ce nombre pour tester d'autres couples
region1 <- nuts2_3 %>% filter(NUTS_ID == adjacency_final$NUTS_ID_1[i])
region2 <- nuts2_3 %>% filter(NUTS_ID == adjacency_final$NUTS_ID_2[i])
# Visualisation
ggplot() +
geom_sf(data = region1, fill = "blue", alpha = 0.5) +
geom_sf(data = region2, fill = "red", alpha = 0.5) +
ggtitle(paste("Couple :", adjacency_final$NUTS_ID_1[i], "et", adjacency_final$NUTS_ID_2[i]))
################################################################################
################################################################################
################################################################################
################################################################################
############CREATION FICHIER Frontieres intranationales############
adjacency_intra<- adjacency_final %>%
filter(substr(NUTS_ID_1, 1, 2) == substr(NUTS_ID_2, 1, 2))
adjacency_intra <- adjacency_intra %>%
select(1:2)
############CREATION FICHIER Frontieres intrernationales############
adjacency_inter <- adjacency_final %>%
filter(substr(NUTS_ID_1, 1, 2) != substr(NUTS_ID_2, 1, 2))
adjacency_inter <- adjacency_inter %>%
select(1:2)
###########################################################################
# Récupérer uniquement les codes disponibles dans NUTS2_3_TGF
codes_disponibles <- NUTS2_3_TGF$`GEO (Codes)`
###########################################################################
##################JOINTURE adjacency_intra et NUTS2_3_TGF##################
# Filtrer les adjacency pour ne garder que les lignes appariables
adjacency_intra <- adjacency_intra %>%
filter(NUTS_ID_1 %in% codes_disponibles & NUTS_ID_2 %in% codes_disponibles)
# Jointure pour ID1
adjacency_intra <- adjacency_intra %>%
left_join(NUTS2_3_TGF, by = c("NUTS_ID_1" = "GEO (Codes)")) %>%
rename_with(~ paste0("ID1_", .), all_of(paste0("TGF ", 2011:2019)))
# Jointure pour ID2
adjacency_intra <- adjacency_intra %>%
left_join(NUTS2_3_TGF, by = c("NUTS_ID_2" = "GEO (Codes)")) %>%
rename_with(~ paste0("ID2_", .), all_of(paste0("TGF ", 2011:2019)))
###########################################################################
###########################################################################
##################JOINTURE adjacency_inter et NUTS2_3_TGF##################
# Filtrage des paires appariables seulement
adjacency_inter <- adjacency_inter %>%
filter(NUTS_ID_1 %in% codes_disponibles & NUTS_ID_2 %in% codes_disponibles)
# Jointure pour ID1
adjacency_inter <- adjacency_inter %>%
left_join(NUTS2_3_TGF, by = c("NUTS_ID_1" = "GEO (Codes)")) %>%
rename_with(~ paste0("ID1_", .), all_of(paste0("TGF ", 2011:2019)))
# Jointure pour ID2
adjacency_inter <- adjacency_inter %>%
left_join(NUTS2_3_TGF, by = c("NUTS_ID_2" = "GEO (Codes)")) %>%
rename_with(~ paste0("ID2_", .), all_of(paste0("TGF ", 2011:2019)))
##################Calculs différences intra##################
# Création du dataframe pour les différences intra-nationales
diffs_intra <- adjacency_intra %>%
transmute(
NUTS_ID_1,
NUTS_ID_2,
GEO_ID1 = `GEO (Labels).x`,
GEO_ID2 = `GEO (Labels).y`,
!!!setNames(
lapply(2011:2019, function(y) {
abs(as.numeric(adjacency_intra[[paste0("ID1_TGF ", y)]]) -
as.numeric(adjacency_intra[[paste0("ID2_TGF ", y)]]))
}),
paste0("DIFF_", 2011:2019)
)
)
##################Calculs différences inter##################
# Création du dataframe pour les différences inter-nationales
diffs_inter <- adjacency_inter %>%
transmute(
NUTS_ID_1,
NUTS_ID_2,
GEO_ID1 = `GEO (Labels).x`,
GEO_ID2 = `GEO (Labels).y`,
!!!setNames(
lapply(2011:2019, function(y) {
abs(as.numeric(adjacency_inter[[paste0("ID1_TGF ", y)]]) -
as.numeric(adjacency_inter[[paste0("ID2_TGF ", y)]]))
}),
paste0("DIFF_", 2011:2019)
)
)
#################calculs_VARIATION ANNuelle moyenne de la différence##################
# Calcul de la variation annuelle pour chaque couple de régions
diffs_intra <- diffs_intra %>%
mutate(
# Calcul de la variation annuelle pour chaque année (en évitant la division par 0)
var_2011_2012 = ifelse(DIFF_2011 == 0, NA, (DIFF_2012 - DIFF_2011) / DIFF_2011),
var_2012_2013 = ifelse(DIFF_2012 == 0, NA, (DIFF_2013 - DIFF_2012) / DIFF_2012),
var_2013_2014 = ifelse(DIFF_2013 == 0, NA, (DIFF_2014 - DIFF_2013) / DIFF_2013),
var_2014_2015 = ifelse(DIFF_2014 == 0, NA, (DIFF_2015 - DIFF_2014) / DIFF_2014),
var_2015_2016 = ifelse(DIFF_2015 == 0, NA, (DIFF_2016 - DIFF_2015) / DIFF_2015),
var_2016_2017 = ifelse(DIFF_2016 == 0, NA, (DIFF_2017 - DIFF_2016) / DIFF_2016),
var_2017_2018 = ifelse(DIFF_2017 == 0, NA, (DIFF_2018 - DIFF_2017) / DIFF_2017),
var_2018_2019 = ifelse(DIFF_2018 == 0, NA, (DIFF_2019 - DIFF_2018) / DIFF_2018)
) %>%
mutate(
# Calcul du coefficient multiplicateur pour chaque période
coef_2011_2012 = 1 + var_2011_2012,
coef_2012_2013 = 1 + var_2012_2013,
coef_2013_2014 = 1 + var_2013_2014,
coef_2014_2015 = 1 + var_2014_2015,
coef_2015_2016 = 1 + var_2015_2016,
coef_2016_2017 = 1 + var_2016_2017,
coef_2017_2018 = 1 + var_2017_2018,
coef_2018_2019 = 1 + var_2018_2019
)
# Calcul de la variation annuelle pour chaque couple de régions
diffs_inter <- diffs_inter %>%
mutate(
# Calcul de la variation annuelle pour chaque année (en évitant la division par 0)
var_2011_2012 = ifelse(DIFF_2011 == 0, NA, (DIFF_2012 - DIFF_2011) / DIFF_2011),
var_2012_2013 = ifelse(DIFF_2012 == 0, NA, (DIFF_2013 - DIFF_2012) / DIFF_2012),
var_2013_2014 = ifelse(DIFF_2013 == 0, NA, (DIFF_2014 - DIFF_2013) / DIFF_2013),
var_2014_2015 = ifelse(DIFF_2014 == 0, NA, (DIFF_2015 - DIFF_2014) / DIFF_2014),
var_2015_2016 = ifelse(DIFF_2015 == 0, NA, (DIFF_2016 - DIFF_2015) / DIFF_2015),
var_2016_2017 = ifelse(DIFF_2016 == 0, NA, (DIFF_2017 - DIFF_2016) / DIFF_2016),
var_2017_2018 = ifelse(DIFF_2017 == 0, NA, (DIFF_2018 - DIFF_2017) / DIFF_2017),
var_2018_2019 = ifelse(DIFF_2018 == 0, NA, (DIFF_2019 - DIFF_2018) / DIFF_2018)
) %>%
mutate(
# Calcul du coefficient multiplicateur pour chaque période
coef_2011_2012 = 1 + var_2011_2012,
coef_2012_2013 = 1 + var_2012_2013,
coef_2013_2014 = 1 + var_2013_2014,
coef_2014_2015 = 1 + var_2014_2015,
coef_2015_2016 = 1 + var_2015_2016,
coef_2016_2017 = 1 + var_2016_2017,
coef_2017_2018 = 1 + var_2017_2018,
coef_2018_2019 = 1 + var_2018_2019
)
#################calculs_moyenne_geometrique##################
geom_intra <- diffs_intra %>%
rowwise() %>%
mutate(
mean_geom = {
coef_vals <- c_across(starts_with("coef_"))
coef_vals <- coef_vals[!is.na(coef_vals) & coef_vals > 0]  # Retirer NA et 0 ou négatifs
if (length(coef_vals) > 0) {
exp(mean(log(coef_vals)))
} else {
NA_real_  # Si aucune valeur valable, retourner NA
}
}
) %>%
ungroup() %>%
select(NUTS_ID_1, NUTS_ID_2, GEO_ID1, GEO_ID2, mean_geom)
#####################
geom_inter <- diffs_inter %>%
rowwise() %>%
mutate(
mean_geom = {
coef_vals <- c_across(starts_with("coef_"))
coef_vals <- coef_vals[!is.na(coef_vals) & coef_vals > 0]  # Retirer NA et 0 ou négatifs
if (length(coef_vals) > 0) {
exp(mean(log(coef_vals)))
} else {
NA_real_  # Si aucune valeur valable, retourner NA
}
}
) %>%
ungroup() %>%
select(NUTS_ID_1, NUTS_ID_2, GEO_ID1, GEO_ID2, mean_geom)
#####Typologie des tendances##########
geom_intra <- geom_intra %>%
mutate(
tendance = case_when(
mean_geom < 0.98 ~ "Forte convergence",
mean_geom >= 0.98 & mean_geom < 1.00 ~ "Convergence",
mean_geom >= 1.00 & mean_geom <= 1.02 ~ "Stabilité",
mean_geom > 1.02 & mean_geom <= 1.05 ~ "Divergence",
mean_geom > 1.05 ~ "Forte divergence",
TRUE ~ NA_character_
)
)
geom_inter <- geom_inter %>%
mutate(
tendance = case_when(
mean_geom < 0.98 ~ "Forte convergence",
mean_geom >= 0.98 & mean_geom < 1.00 ~ "Convergence",
mean_geom >= 1.00 & mean_geom <= 1.02 ~ "Stabilité",
mean_geom > 1.02 & mean_geom <= 1.05 ~ "Divergence",
mean_geom > 1.05 ~ "Forte divergence",
TRUE ~ NA_character_
)
)
mean(geom_inter$mean_geom, na.rm = TRUE)
mean(geom_intra$mean_geom, na.rm = TRUE)
### 1. Fusionner les deux bases de données (geom_inter et geom_intra)
geom_combined <- bind_rows(geom_inter, geom_intra)
################################################################################
################################################################################
################################################################################
################################################################################
get_clean_common_boundary <- function(id1, id2, regions_sf) {
tryCatch({
region1 <- regions_sf %>% filter(NUTS_ID == id1)
region2 <- regions_sf %>% filter(NUTS_ID == id2)
boundary1 <- st_geometry(st_boundary(region1))
boundary2 <- st_geometry(st_boundary(region2))
common_raw <- st_intersection(boundary1, boundary2)
# S'il n'y a rien
if (length(common_raw) == 0) return(st_geometrycollection())
# Si c'est déjà une ligne ou multilignes
if (inherits(common_raw, "sfc_LINESTRING") || inherits(common_raw, "sfc_MULTILINESTRING")) {
return(common_raw)
}
# Si c'est une collection, on extrait les lignes
if (inherits(common_raw, "sfc_GEOMETRY")) {
lines <- st_collection_extract(common_raw, "LINESTRING")
if (length(lines) == 0) return(st_geometrycollection())
return(lines)
}
# Sinon on retourne vide
return(st_geometrycollection())
}, error = function(e) {
message("Erreur pour le couple : ", id1, " - ", id2, " → ", e$message)
st_geometrycollection()
})
}
################################################################################
################################################################################
################################################################################
################################################################################
boundaries_list <- map2(
geom_combined$NUTS_ID_1,
geom_combined$NUTS_ID_2,
~ get_clean_common_boundary(.x, .y, nuts2_3)
)
################################################################################
################################################################################
################################################################################
################################################################################
# Nettoyage : extraire les vraies géométries (sfg) de la liste
boundaries_clean <- map(boundaries_list, function(x) {
if (inherits(x, "sfg")) {
x
} else if (inherits(x, "sfc") && length(x) == 1 && inherits(x[[1]], "sfg")) {
x[[1]]
} else if (inherits(x, "list") && length(x) == 1 && inherits(x[[1]], "sfg")) {
x[[1]]
} else {
st_geometrycollection()
}
})
# Création sécurisée de l'objet sfc
boundaries_sfc <- st_sfc(boundaries_clean, crs = st_crs(nuts2_3))
# 6. Créer l'objet sf avec les métadonnées et la géométrie des frontières
geom_combined_sf <- st_sf(geom_combined, geometry = boundaries_sfc)
# 7. Séparer les géométries selon leur type
points_sf <- geom_combined_sf[st_geometry_type(geom_combined_sf) == "POINT", ]
lines_sf <- geom_combined_sf[st_geometry_type(geom_combined_sf) %in% c("LINESTRING", "MULTILINESTRING"), ]
# 8. Caster toutes les lignes en MULTILINESTRING (pour homogénéité)
lines_sf <- st_cast(lines_sf, "MULTILINESTRING")
# 9. On garde uniquement les lignes valides pour la cartographie
geom_combined_sf <- lines_sf
# Transformer les données en EPSG:4326 (WGS84) pour leaflet
nuts3_wgs84 <- st_transform(nuts3, crs = 4326)
geom_combined_sf_wgs84 <- st_transform(geom_combined_sf, crs = 4326)
################################################################################
################################################################################
################################################################################
################################################################################
####CARTOGRAPHIE#####
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
# Définir les seuils
min_val <- 0.4981127
max_val <- 2.992131
breaks <- c(min_val, 0.9, 1.1, max_val)
# Nombre de couleurs proportionnel aux longueurs des intervalles
total_colors <- 300
ratio_blue  <- (0.9 - min_val) / (max_val - min_val)
ratio_green <- (1.1 - 0.9) / (max_val - min_val)
ratio_red   <- (max_val - 1.1) / (max_val - min_val)
n_blue  <- round(total_colors * ratio_blue)
n_green <- round(total_colors * ratio_green)
n_red   <- total_colors - n_blue - n_green  # pour garantir le total à 300
# Créer les sous-palettes
palette_bleu <- colorRampPalette(c("darkgreen", "forestgreen", "lightgreen"))(n_blue)
palette_vert <- colorRampPalette(c("lightgray", "darkgray"))(n_green)
palette_rouge <- colorRampPalette(c("indianred1", "indianred3", "darkred"))(n_red)
# Fusionner les couleurs
combined_colors <- c(palette_bleu, palette_vert, palette_rouge)
# Créer la palette colorNumeric avec les bonnes limites
valeurs <- geom_combined_sf_wgs84$mean_geom
pal_couleur <- colorNumeric(
palette = combined_colors,
domain = c(min_val, max_val),
na.color = "transparent"
)
# Carte leaflet avec légende adaptée
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolylines(
data = geom_combined_sf_wgs84,
color = ~pal_couleur(mean_geom),
weight = 3,
opacity = 1,
label = ~paste0("Frontière: ", NUTS_ID_1, " - ", NUTS_ID_2, "<br>",
"Moyenne géométrique: ", round(mean_geom, 3))
) %>%
addLegend(
pal = pal_couleur,
values = valeurs,
opacity = 1,
title = "Moyenne géométrique",
position = "bottomright"
)
min(geom_combined_sf_wgs84$mean_geom, na.rm = TRUE)
max(geom_combined_sf_wgs84$mean_geom, na.rm = TRUE)
################################################################################
################################################################################
# Combine les deux colonnes, puis retire les doublons
valeurs_uniques <- unique(c(NUTS2_3_TGF$`GEO (Codes)`))
# Crée un dataframe à partir de ce vecteur
df_uniques <- data.frame(valeur_unique = valeurs_uniques)
# Exporter df_final en fichier Excel
write.xlsx(df_uniques, file = "GEOCODES.xlsx", overwrite = TRUE)
saveRDS(geom_combined_sf_wgs84, file = "geom_combined_sf_wgs84.rds")
library(readxl)
library(tidyverse)
library(haven)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(stringr)
library(RColorBrewer)
library(openxlsx)
library(sf)
library(eurostat)
library(purrr)
library(spdep)
library(rmapshaper)
library(leaflet)
library(htmlwidgets)
################################################################################
setwd("C:/Users/schmi/OneDrive/Bureau/Données_mémoire/Bases_Eurostat")
geom_combined_sf_wgs84 <- readRDS("geom_combined_sf_wgs84.rds")
library(readxl)
library(tidyverse)
library(haven)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(stringr)
library(RColorBrewer)
library(openxlsx)
library(sf)
library(eurostat)
library(purrr)
library(spdep)
library(rmapshaper)
library(leaflet)
library(htmlwidgets)
################################################################################
setwd("C:/Users/schmi/OneDrive/Bureau/Données_mémoire/Bases_Eurostat")
################################################################################
setwd("C:/Users/schmi/OneDrive/Bureau/Données_mémoire/Donnees pretes")
geom_combined_sf_wgs84 <- readRDS("geom_combined_sf_wgs84.rds")
library(readxl)
library(tidyverse)
library(haven)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(stringr)
library(RColorBrewer)
library(openxlsx)
library(sf)
library(eurostat)
library(purrr)
library(spdep)
library(rmapshaper)
library(leaflet)
library(htmlwidgets)
################################################################################
setwd("C:/Users/schmi/OneDrive/Bureau/Données_mémoire/Bases_Eurostat")
################################################################################
setwd("C:/Users/schmi/OneDrive/Bureau/Données_mémoire/Donnees pretes")
geom_combined_sf_wgs84 <- readRDS("geom_combined_sf_wgs84.rds")
View(geom_combined_sf_wgs84)
geom_international <- geom_combined_sf_wgs84 %>%
filter(substr(NUTS_ID_1, 1, 2) != substr(NUTS_ID_2, 1, 2))
View(geom_international)
